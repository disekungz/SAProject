package controller

import (
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sa-project/configs"
	"github.com/sa-project/entity"
	"gorm.io/gorm"
)

// RequestingInput - Struct for receiving JSON from Frontend (for creating/editing main data)
type RequestingInput struct {
	// Requesting_NO is generated by the server, so it's removed from input.
	PID            *uint  `json:"PID" binding:"required"`
	Amount_Request uint   `json:"Amount_Request" binding:"required,min=1"`
	Request_Date   string `json:"Request_Date" binding:"required"`
	Staff_ID       *uint  `json:"Staff_ID" binding:"required"`
}

// StatusUpdateInput - Struct for receiving JSON (for updating status only)
type StatusUpdateInput struct {
	Status_ID *uint `json:"Status_ID" binding:"required"`
}

// --- Helper Function ---

// generateNextRequestNo генерує наступний номер запиту на основі останнього запису в БД за поточний рік.
// Він розроблений, щоб бути безпечним для транзакцій, приймаючи дескриптор *gorm.DB.
func generateNextRequestNo(db *gorm.DB) (string, error) {
	var latestRequesting entity.Requesting
	loc, _ := time.LoadLocation("Asia/Bangkok")
	// Отримати поточний рік за буддійською ерою (พ.ศ.)
	currentYear := time.Now().In(loc).Year() + 543

	// Запит на останній запит у поточному буддійському році.
	// Ми сортуємо за requesting_no за спаданням і беремо перший.
	err := db.
		Where("SUBSTRING(requesting_no, 6, 4) = ?", fmt.Sprintf("%d", currentYear)).
		Order("requesting_no desc").
		First(&latestRequesting).Error

	nextSeqNum := 1
	if err == nil {
		// Запис знайдено, тому ми розбираємо його номер і збільшуємо.
		parts := strings.Split(latestRequesting.Requesting_NO, "/")
		if len(parts) == 2 {
			currentNum, err := strconv.Atoi(parts[0])
			if err != nil {
				// Цей випадок в ідеалі не повинен траплятися, якщо дані послідовні.
				return "", fmt.Errorf("failed to parse sequence number from: %s", latestRequesting.Requesting_NO)
			}
			nextSeqNum = currentNum + 1
		}
	} else if err != gorm.ErrRecordNotFound {
		// Сталася фактична помилка бази даних.
		return "", fmt.Errorf("failed to query latest request number: %w", err)
	}
	// Якщо err має значення gorm.ErrRecordNotFound, це означає, що для поточного року немає записів.
	// У цьому випадку ми правильно починаємо послідовність з 1.

	// Відформатувати новий номер як "0001/2567"
	newRequestNo := fmt.Sprintf("%04d/%d", nextSeqNum, currentYear)
	return newRequestNo, nil
}


// --- API Handlers ---

// GetRequestings - Fetches all requesting records
func GetRequestings(c *gin.Context) {
	var requestings []entity.Requesting
	if err := configs.DB().
		Preload("Parcel").
		Preload("Staff").
		Preload("Status").
		Order("requesting_no desc"). // Order by newest first
		Find(&requestings).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, requestings)
}

// GetNextRequestNo - Generates the next request number (XXXX/YYYY)
func GetNextRequestNo(c *gin.Context) {
	newRequestNo, err := generateNextRequestNo(configs.DB())
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"request_no": newRequestNo})
}

// CreateRequesting - Creates a new requesting record
func CreateRequesting(c *gin.Context) {
	var input RequestingInput
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data format: " + err.Error()})
		return
	}

	requestDate, err := time.Parse("2006-01-02", input.Request_Date)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Request_Date format, use YYYY-MM-DD"})
		return
	}

	// Start a new database transaction
	tx := configs.DB().Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Generate Requesting_NO within the transaction to prevent race conditions
	newRequestNo, err := generateNextRequestNo(tx)
	if err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Set default status to 'รอดำเนินการ' (ID = 1)
	statusID := uint(1)

	requesting := entity.Requesting{
		Requesting_NO:  newRequestNo,
		PID:            input.PID,
		Amount_Request: input.Amount_Request,
		Request_Date:   requestDate,
		StaffID:        input.Staff_ID,
		Status_ID:      &statusID,
	}

	if err := tx.Create(&requesting).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create requesting: " + err.Error()})
		return
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		tx.Rollback() // Rollback on commit error
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Transaction commit failed: " + err.Error()})
		return
	}

	// Preload associations for the response
	configs.DB().Preload("Parcel").Preload("Staff").Preload("Status").First(&requesting, requesting.Requesting_ID)
	c.JSON(http.StatusCreated, requesting)
}

// UpdateRequesting - Updates the main data of a requesting record (excluding status)
func UpdateRequesting(c *gin.Context) {
	id := c.Param("id")
	var requesting entity.Requesting
	if err := configs.DB().First(&requesting, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Requesting not found"})
		return
	}

	// A requesting that is not pending should not be editable.
	if requesting.Status_ID != nil && *requesting.Status_ID != 1 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ไม่สามารถแก้ไขคำร้องที่ดำเนินการไปแล้วได้"})
		return
	}

	var input RequestingInput
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data format: " + err.Error()})
		return
	}

	requestDate, err := time.Parse("2006-01-02", input.Request_Date)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Request_Date format, use YYYY-MM-DD"})
		return
	}

	updateData := map[string]interface{}{
		"PID":            input.PID,
		"Amount_Request": input.Amount_Request,
		"Request_Date":   requestDate,
		"Staff_ID":       input.Staff_ID,
	}

	if err := configs.DB().Model(&requesting).Updates(updateData).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update requesting: " + err.Error()})
		return
	}

	configs.DB().Preload("Parcel").Preload("Staff").Preload("Status").First(&requesting, id)
	c.JSON(http.StatusOK, requesting)
}

// UpdateRequestingStatus - Updates only the status of a requesting record
func UpdateRequestingStatus(c *gin.Context) {
	id := c.Param("id")
	var requesting entity.Requesting
	if err := configs.DB().First(&requesting, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Requesting not found"})
		return
	}

	var input StatusUpdateInput
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data format: " + err.Error()})
		return
	}

	var status entity.Status
	if err := configs.DB().First(&status, *input.Status_ID).Error; err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Status ID"})
		return
	}

	if err := configs.DB().Model(&requesting).Update("status_id", input.Status_ID).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update requesting status"})
		return
	}

	configs.DB().Preload("Parcel").Preload("Staff").Preload("Status").First(&requesting, id)
	c.JSON(http.StatusOK, requesting)
}

// DeleteRequesting - Deletes a requesting record
func DeleteRequesting(c *gin.Context) {
	id := c.Param("id")
	var requesting entity.Requesting
	if err := configs.DB().First(&requesting, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Requesting not found"})
		return
	}

	// You might want to prevent deletion of approved/rejected requests.
	// if *requesting.Status_ID != 1 {
	// 	c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot delete a processed request"})
	// 	return
	// }

	if err := configs.DB().Delete(&entity.Requesting{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete requesting"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "Requesting deleted successfully"})
}
